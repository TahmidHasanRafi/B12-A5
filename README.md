1.	getElementById, getElementsByClassName, querySelector, and querySelectorAll are all used to target elements in the DOM, and they all work differently and target various things. getElementById – selects one element by its id and speeds are generally faster than the other three. getElementsByClassName returns a live HTML collection of elements with the given class name, so it automatically updates when the DOM is changed. querySelector, on the other hand, accepts any valid CSS selector and returns the first matching element, while querySelectorAll returns all matching elements as a static NodeList (does not update dynamically). getElementById is faster since you focus on one element. The other methods are more flexible in that you can make broader selections based on class names or complex CSS.
2.	Event Bubbling is a concept in JavaScript where an event triggered on an element propagates upwards through its ancestors in the DOM tree. When an event is triggered on a child element, it first executes the event handler attached to that child, and then "bubbles up" to the parent element, then to the parent’s parent, and so on, until it reaches the root of the document (usually the document object).
For example, if a click event occurs on a button inside a div, the event will trigger the button’s event handler first. After that, it will bubble up to the div, then to the body, and finally to the document if no one stops it.
How it works:
•	The event starts from the target element (the one that was clicked or interacted with) and then bubbles up to the parent elements.
•	If an event handler is attached to any of the ancestor elements, it will be executed during the bubbling phase.
•	Event.stopPropagation() can be used to stop the event from bubbling up further.
This mechanism allows event delegation, where a single event handler can be attached to a parent element to handle events for its child elements, rather than attaching individual handlers to each child.



3.	Event Delegation in JavaScript is a pattern where you add a single event listener to a parent element to listen for events that happen inside it. This system relies on event bubbling, events that are triggered from a child element will bubble back to the parent elements in their DOM context. Rather than a separate event listener on each child element, the parent listens for events, and from examining the event, works if the target child is the right one. target property.
4.	There are a few good reasons to use event delegation:Performance - Reducing the number of event listeners can be a big win, especially on a page with lots of elements, say a table with one event listener per row.Centrally manage events - Delegated events are really easy to deal with for dynamically added elements, you don't need to remember to add listeners to new elements, they will just work.Flatter code - It can become all to easy to have a mountain of event listeners on a page, delegating events basically strips the code out of an event handler, instead binding all events to the single parent, depending on your perspective it can keep your code clean and slim. It is also airthmetic to the memory usage as there are less listeners to handle each of the elements.


5.	preventDefault() is as for stopPropagation() are control methods in JS for how events behave, but do different things. The preventDefault() function is used to prevent the default action of the event. For example, it can prevent a form from submitting, or prevent a link from following the URL it points to. And event.stopPropagation() is to prevent the event from bubbling up or capturing down (and hence triggering event listeners) on DOM hierarchy (ancestors or parent at a higher level). While preventDefault() is used to stop the default behavior such as submitting a form or clicking on a link, stopPropagation() is used when you don’t want other listeners to react to the same event, and only the listener you specify run through it.

